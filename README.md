# goit-algo2-hw-05

**Design and Analysis of Algorithms. HW 5. Big data algorithms**

## Завдання 1. Перевірка унікальності паролів за допомогою фільтра Блума

Створіть функцію для перевірки унікальності паролів за допомогою фільтра Блума. Ця функція має визначати, чи використовувався пароль раніше, без необхідності зберігати самі паролі.

**Технічні умови**

1. Реалізуйте клас `BloomFilter`, який забезпечує додавання елементів до фільтра та перевірку наявності елемента у фільтрі.
2. Реалізуйте функцію `check_password_uniqueness`, яка використовує екземпляр `BloomFilter` та перевіряє список нових паролів на унікальність. Вона має повертати результат перевірки для кожного пароля.
3. Забезпечте коректну обробку всіх типів даних. Паролі слід обробляти просто як рядки, без хешування. Порожні або некоректні значення також мають бути враховані та оброблені належним чином.
4. Функція та клас мають працювати з великими наборами даних, використовуючи мінімум пам’яті.

**Приклад використання**

```
if __name__ == "__main__":
    # Ініціалізація фільтра Блума
    bloom = BloomFilter(size=1000, num_hashes=3)

    # Додавання існуючих паролів
    existing_passwords = ["password123", "admin123", "qwerty123"]
    for password in existing_passwords:
        bloom.add(password)

    # Перевірка нових паролів
    new_passwords_to_check = ["password123", "newpassword", "admin123", "guest"]
    results = check_password_uniqueness(bloom, new_passwords_to_check)

    # Виведення результатів
    for password, status in results.items():
        print(f"Пароль '{password}' - {status}.")

```

## Завдання 2. Порівняння продуктивності HyperLogLog із точним підрахунком унікальних елементів

Створіть скрипт для порівняння точного підрахунку унікальних елементів та підрахунку за допомогою `HyperLogLog`.

**Технічні умови**

1. Завантажте набір даних із реального лог-файлу `lms-stage-access.log`, що містить інформацію про IP-адреси.
2. Реалізуйте метод для точного підрахунку унікальних IP-адрес за допомогою структури set.
3. Реалізуйте метод для наближеного підрахунку унікальних IP-адрес за допомогою `HyperLogLog`.
4. Проведіть порівняння методів за часом виконання.

**Приклад виводу результатів**

```
Результати порівняння:
                       Точний підрахунок   HyperLogLog
Унікальні елементи              100000.0      99652.0
Час виконання (сек.)                0.45          0.1
```

## Результат

Завантажено 29553 IP-адрес

```
                        Точний підрахунок   HyperLogLog
Унікальні елементи      28                  28
Час виконання (сек.)    0.001               0.038979
```

## Порівняння результатів

В нашому випадку унікальних значень 28, і `Точний підрахунок` спрацював швидше ніж `HyperLogLog`

Якщо унікальних значень дуже мало, то `Точний підрахунок` виконується набагато швидше, бо:

- Його перевірки виконуються швидко (все міститься в кеші процесора).
- Мало пам’яті потрібно для set(), тому він працює практично миттєво.
- `HyperLogLog` все одно проходить по всіх IP-адресах, створюючи хеші, і на маленькому обсязі даних це займає додатковий час.

При цьому `HyperLogLog` буде працювати швидше на великих масивах даних.мВін не зберігає самі значення, а працює з хешами. Це дає йому дві головні переваги:

- Мінімальне використання пам'яті (`O(1)` для вставки).
- Час виконання майже не залежить від розміру вхідного набору.

При цьому `Точний підрахунок` використовує `O(n)` пам’яті і `O(n)` часу, оскільки кожне нове значення потрібно перевіряти та додавати у множину.

Якщо б у нас було `100 000` унікальних IP-адрес, `HyperLogLog` виграв би в продуктивності, бо set() займає дуже багато пам’яті і довго шукає унікальні значення.
